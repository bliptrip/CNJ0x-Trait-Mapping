---
title: "QTL Pipeline"
author: "Andrew Maule"
date: "3/24/2021"
output: html_document
params:
  install_deps: FALSE #Whether to install dependencies
  clean_traits: FALSE #Whether to run the code to clean up the trait data: Remove outliers, etc
  workflow: 11 
  sandbox: sandbox #Name of folder to place circos files needed to render QTL circos plots.
---

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, include=TRUE, message=FALSE, root.dir=paste0(getwd(),"/R"));
workflow  = paste0("../../Workflows/",params$workflow);
rRoot     = paste0(getwd(),"/R")
# Set environment variables that will be available for bash scripts (Make invocation)   
Sys.setenv(WORKFLOW=workflow)
Sys.setenv(SANDBOX=params$sandbox)
```

## Load universally important libraries, and source local library of usefulFunctions

```{r imports, include=FALSE}
setwd(rRoot)
library(tidyverse)
library(cowplot)
library(corrplot)
library(ggcorrplot)
library(magrittr)
library(seriation)
source("usefulFunctions.R")
```

## Install Package Dependencies

```{r deps, eval=params$install_deps, include=FALSE}
setwd(rRoot)
source('packagedeps.R', echo=TRUE)
```

## QTL Analysis Pipeline for CNJ02/CNJ04 Upright Data

This code represents the full pipeline for mapping QTLs in two half-sib populations, CNJ02 (Mullica Queen x Crimson Queen, n = 168) and CNJ04 (Mullica Queen x Stevens reciprocal cross, n = 72).

Most of this functionality was originally written in RScript and invoked through \*nix Makefiles. The core functionality will continue to be implemented in the RScript code, but the pipeline flow will be documented and executed through this document, where possible. The only code that will continue to be run through \*nix Makefiles is that which relates to running permutations on the [University of Wisconsin-Madison Center for High-Throughput Computing HTCondor](https://chtc.cs.wisc.edu/) system.

------------------------------------------------------------------------

## Phenotype Data Assesment and Cleaning

This code reads in the collated/combined phenotypic data for both populations, assesses inconsistencies in data, and uses linear models to aid in trimming outliers.

***NOTE: The following code only needs to be run once, unless the underlying code is changed.***

```{r test-code, eval=params$clean_traits, echo=FALSE}
setwd(rRoot);
source('analyze_remove_outliers.R', echo=TRUE);
```

------------------------------------------------------------------------

## Calculate Upright Means Within Years

```{r means}
setwd(rRoot)
source('qtl_pipeline_00_1_means.R');
```

## Generate Derivative Phenotypes in Upright Dataset

Generate a mean fruit weight and length/width ratio for the upright datasets.

```{r generate-deriv-phenos, include=TRUE, echo=TRUE}
setwd(rRoot)

cnjpop.pheno.p1.means.df <- read_csv(pheno_dpath2fpath("Data-combined-collated.cnj04.means.csv"))
cnjpop.pheno.p2.means.df <- read_csv(pheno_dpath2fpath("Data-combined-collated.cnj02.means.csv"))

#Generate MFM and LvW traits for upright data
cnjpop.pheno.p2.means.df <- cnjpop.pheno.p2.means.df %>% mutate(ULvW = berry_length/berry_width, UMFM = total_berry_weight/num_berries)
cnjpop.pheno.p1.means.df <- cnjpop.pheno.p1.means.df %>% mutate(ULvW = berry_length/berry_width, UMFM = total_berry_weight/num_berries)
```

## Merge Upright and Plot Datasets

### Read in Plot Data, Merge Datasets, and Define Correlation Plot Functions, Calculate Gaussian-Standardized Values for Traits, Strip off additional outliers, and Abbreviate year/month designators for Compact Graph Display

```{r plotdata-read-merge, include=TRUE, echo=TRUE}
col1            <- colorRampPalette(c("blue", "white", "red")) 

setwd(rRoot)
cnj02_pdata.tb  <- read_csv(pheno_dpath2fpath("PlotData/CNJ02_PlotData.csv"))
cnj04_pdata.tb  <- read_csv(pheno_dpath2fpath("PlotData/CNJ04_PlotData.csv"))
#Copy Stevens and Mullica Queen entries to CNJ04 dataset, since they are only in CNJ02 datasets
cnj04_pdata.parents.tb <- cnj02_pdata.tb %>% filter(grepl("(Mullica_Queen)|(Stevens)", accession_name, perl=TRUE))
cnj04_pdata.tb <- cnj04_pdata.tb %>% bind_rows(cnj04_pdata.parents.tb)
#Rename the accession names to be consistent with the upright dataset (replace _ with -)

#Merge the upright data with the plot data.  Pivot the months wider in the plot dataset.
cnj02.merged.tb <- cnjpop.pheno.p2.means.df %>% 
                    full_join(cnj02_pdata.tb %>% pivot_wider(names_from=month, values_from=TY:PAC), by=c("accession_name", "row", "column", "year"))
cnj04.merged.tb <- cnjpop.pheno.p1.means.df %>% 
                    full_join(cnj04_pdata.tb %>% pivot_wider(names_from=month, values_from=TY:PAC), by=c("accession_name", "row", "column", "year"))

#Merge the upright data with the plot data.  Average the months in plot dataset.
cnj02_pdata.mmeans.tb   <- cnj02_pdata.tb %>% 
                            group_by(accession_name, row, column, year) %>%
                            summarise(across(.cols=TY:PAC, mean)) %>%
                            ungroup() 
cnj02.merged.mmeans.tb  <- cnjpop.pheno.p2.means.df %>%
                            full_join(cnj02_pdata.mmeans.tb, by=c("accession_name", "row", "column", "year"))
cnj04_pdata.mmeans.tb   <- cnj04_pdata.tb %>% 
                            group_by(accession_name, row, column, year) %>%
                            summarise(across(.cols=TY:PAC, mean)) %>%
                            ungroup() 
cnj04.merged.mmeans.tb  <- cnjpop.pheno.p1.means.df %>%
                            full_join(cnj04_pdata.mmeans.tb, by=c("accession_name", "row", "column", "year"))


#Generate Average Biennial-Berry Indexes for UTBM, TY, and SFY
#For CNJ02 population, it is possible to do this over two years b/c we have 3 consecutive years.  For CNJ04, we can only do for one year.
cnj02.bbi.diffs.tb <- cnj02.merged.mmeans.tb %>%
                        dplyr::select(c(year,accession,accession_name,row,column,total_berry_weight,TY,SFY)) %>%
                        pivot_wider(names_from=year, values_from=c(total_berry_weight:SFY)) %>%
                        mutate( BBI_UTBM_2011=abs((total_berry_weight_2012-total_berry_weight_2011)/(total_berry_weight_2012+total_berry_weight_2011)),
                                BBI_UTBM_2012=abs((total_berry_weight_2013-total_berry_weight_2012)/(total_berry_weight_2013+total_berry_weight_2012)),
                                BBI_TY_2011=abs((TY_2012-TY_2011)/(TY_2012+TY_2011)),
                                BBI_TY_2012=abs((TY_2013-TY_2012)/(TY_2013+TY_2012)),
                                BBI_SFY_2011=abs((SFY_2012-SFY_2011)/(SFY_2012+SFY_2011)),
                                BBI_SFY_2012=abs((SFY_2013-SFY_2012)/(SFY_2013+SFY_2012))) %>%
                        pivot_longer(matches("(^BBI+)|(^total_berry_weight+)|(^TY+)|(^SFY+)"), names_pattern="(.+)_([^_]+$)", names_to=c(".value","year")) %>%
                        mutate( year = as.double(year) ) %>%
                        dplyr::select(!matches("(^total_berry_weight+)|(^TY+)|(^SFY+)")) %>%
                        inner_join(cnj02.merged.mmeans.tb, by=c("year","accession","accession_name", "row", "column"))
cnj02.merged.mmeans.tb <- cnj02.bbi.diffs.tb
  
cnj04.bbi.diffs.tb <- cnj04.merged.mmeans.tb %>%
                        dplyr::select(c(year,accession,accession_name,row,column,c(total_berry_weight,TY,SFY))) %>%
                        pivot_wider(names_from=year, values_from=c(total_berry_weight:SFY)) %>%
                        mutate( BBI_UTBM_2011=abs((total_berry_weight_2012-total_berry_weight_2011)/(total_berry_weight_2012+total_berry_weight_2011)),
                                BBI_TY_2011=abs((TY_2012-TY_2011)/(TY_2012+TY_2011)),
                                BBI_SFY_2011=abs((SFY_2012-SFY_2011)/(SFY_2012+SFY_2011)) ) %>%
                        pivot_longer(matches("(^BBI+)|(^total_berry_weight+)|(^TY+)|(^SFY+)"), names_pattern="(.+)_([^_]+$)", names_to=c(".value","year")) %>%
                        mutate( year = as.double(year) ) %>%
                        dplyr::select(!matches("(^total_berry_weight+)|(^TY+)|(^SFY+)")) %>%
                        inner_join(cnj04.merged.mmeans.tb, by=c("year","accession","accession_name","row","column"))
cnj04.merged.mmeans.tb <- cnj04.bbi.diffs.tb

standardize <- function(vec) {
  z <- (vec-mean(vec, na.rm=T))/sd(vec, na.rm=T)
  z[z < -3.0] <- NA
  z[z > 3.0] <- NA
  return(z)
}

id_columns <- c("year","accession_name","accession","row","column")

cnj02.merged.mmeans.std.tb <- cbind(cnj02.merged.mmeans.tb %>% dplyr::select(all_of(id_columns)), apply(cnj02.merged.mmeans.tb %>% dplyr::select(!id_columns), 2, standardize))
cnj02.merged.mmeans.tb[is.na(cnj02.merged.mmeans.std.tb)] <- NA
cnj04.merged.mmeans.std.tb <- cbind(cnj04.merged.mmeans.tb %>% dplyr::select(all_of(id_columns)), apply(cnj04.merged.mmeans.tb %>% dplyr::select(!id_columns), 2, standardize))
cnj04.merged.mmeans.tb[is.na(cnj04.merged.mmeans.std.tb)] <- NA

#Rename columns to shortened names
traits.tb     <- read_csv(file=paste0(workflow,"/configs/model-traits.cfg.csv"))
traits        <- unique(traits.tb$trait)
trait_labels  <- unique(traits.tb$label_short)

trait_colnames_cnj02 <- colnames(cnj02.merged.tb)
trait_colnames_cnj02.mmeans <- colnames(cnj02.merged.mmeans.tb)
trait_colnames_cnj04 <- colnames(cnj04.merged.tb)
trait_colnames_cnj04.mmeans <- colnames(cnj04.merged.mmeans.tb)

for( i in 1:length(traits) ) {
  trait <- traits[i]
  trait_label <- trait_labels[i]
  if( trait %in% trait_colnames_cnj02 ) {
    cnj02.merged.tb <- cnj02.merged.tb %>% rename_with(~ gsub(trait, trait_label, .x, fixed=TRUE), .cols=trait)
    cnj02.merged.mmeans.std.tb <- cnj02.merged.mmeans.std.tb %>% rename_with(~ gsub(trait, trait_label, .x, fixed=TRUE), .cols=trait)
  }
  if( trait %in% trait_colnames_cnj02.mmeans ) {
    cnj02.merged.mmeans.tb <- cnj02.merged.mmeans.tb %>% rename_with(~ gsub(trait, trait_label, .x, fixed=TRUE), .cols=trait)
  }
  if( trait %in% trait_colnames_cnj04 ) {
    cnj04.merged.tb <- cnj04.merged.tb %>% rename_with(~ gsub(trait, trait_label, .x, fixed=TRUE), .cols=trait)
    cnj04.merged.mmeans.std.tb <- cnj04.merged.mmeans.std.tb %>% rename_with(~ gsub(trait, trait_label, .x, fixed=TRUE), .cols=trait)
  }
  if( trait %in% trait_colnames_cnj02.mmeans ) {
    cnj04.merged.mmeans.tb <- cnj04.merged.mmeans.tb %>% rename_with(~ gsub(trait, trait_label, .x, fixed=TRUE), .cols=trait)
  }
}

cnj02.merged.tb <- cnj02.merged.tb %>% 
                  mutate(year = gsub("20([0-9]{2})", "\\1", year)) %>% #Abbreviate the years for compact display of labels
                  rename_with(~ gsub("_", "", .x, fixed = TRUE), .cols=!c(accession_name)) %>%
                  rename_with(~ gsub("September", "Sep", .x, fixed = TRUE)) %>%
                  rename_with(~ gsub("October", "Oct", .x, fixed = TRUE))

cnj04.merged.tb <- cnj04.merged.tb %>% 
                  mutate(year = gsub("20([0-9]{2})", "\\1", year)) %>% #Abbreviate the years for compact display of labels
                  rename_with(~ gsub("_", "", .x, fixed = TRUE), .cols=!c(accession_name)) %>%
                  rename_with(~ gsub("September", "Sep", .x, fixed = TRUE)) %>%
                  rename_with(~ gsub("October", "Oct", .x, fixed = TRUE))
cnj02.merged.mmeans.tb <- cnj02.merged.mmeans.tb %>%
                            mutate(year = gsub("20([0-9]{2})", "\\1", year)) #Abbreviate the years for compact display of labels
cnj02.merged.mmeans.std.tb <- cnj02.merged.mmeans.std.tb %>%
                            mutate(year = gsub("20([0-9]{2})", "\\1", year)) #Abbreviate the years for compact display of labels
cnj04.merged.mmeans.tb <- cnj04.merged.mmeans.tb %>%
                            mutate(year = gsub("20([0-9]{2})", "\\1", year)) #Abbreviate the years for compact display of labels
cnj04.merged.mmeans.std.tb <- cnj04.merged.mmeans.std.tb %>%
                            mutate(year = gsub("20([0-9]{2})", "\\1", year)) #Abbreviate the years for compact display of labels

#Save merged data
write_csv(cnj02.merged.tb, file=pheno_dpath2fpath("MergedData/CNJ02_PlotData.csv"))
write_csv(cnj04.merged.tb, file=pheno_dpath2fpath("MergedData/CNJ04_PlotData.csv"))
write_csv(cnj02.merged.mmeans.tb, file=pheno_dpath2fpath("MergedData/CNJ02_PlotData.mmeans.csv"))
write_csv(cnj02.merged.mmeans.std.tb, file=pheno_dpath2fpath("MergedData/CNJ02_PlotData.mmeans.std.csv"))
write_csv(cnj04.merged.mmeans.tb, file=pheno_dpath2fpath("MergedData/CNJ04_PlotData.mmeans.csv"))
write_csv(cnj04.merged.mmeans.std.tb, file=pheno_dpath2fpath("MergedData/CNJ04_PlotData.mmeans.std.csv"))
```

#Use seriation package to generate simililarity matrix b/w genotypes and traits -- use standardized values for traits

```{r plot-seriation, include=TRUE, echo=TRUE}
d_cnj02 <- dist(cnj02.merged.mmeans.std.tb %>% select(BBI_UTBM:PAC))
dissplot(d_cnj02)
```

### Generate Density Graphs (Histograms) of All Traits and Plot

```{r plot-densities, include=TRUE, echo=TRUE}
setwd(rRoot)

cnj02.merged.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ02_PlotData.csv"))
cnj02.merged.mmeans.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ02_PlotData.mmeans.csv"))
cnj02.merged.mmeans.std.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ02_PlotData.mmeans.std.csv"))
cnj04.merged.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ04_PlotData.csv"))
cnj04.merged.mmeans.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ04_PlotData.mmeans.csv"))
cnj02.merged.mmeans.std.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ02_PlotData.mmeans.std.csv"))

generateDensityPlots <- function(data, traits, filename) {
  g <- data %>%
          pivot_longer(!c(year,accession_name,accession,row,column),names_to="trait",values_to="values") %>%
          filter( trait %in% traits ) %>%
          ggplot(aes(x=values,group=factor(year),fill=factor(year))) +
          geom_density(aes(y=..scaled..), alpha=0.5) +
          facet_grid(cols=vars(trait), scales="free_x") +
          guides(fill=guide_legend(title="Year")) +
          xlab("Trait Values") +
          ylab("Density") +
          theme(  axis.text.x = element_text(face="bold", size=16, angle = 60, hjust = 1),
                  axis.text.y = element_text(face="bold", size=16),
                  strip.text  = element_text(face="bold", size=18),
                  legend.title = element_text(fac="bold", size=16),
                  legend.text = element_text(fac="bold", size=12),
                  legend.key.size = ggplot2::unit(1,"cm"),
                  axis.title  = element_text(face="bold",size=24),
                  plot.title   = element_text(face="bold",size=26, hjust=0.5),
                  plot.subtitle = element_text(size=48, hjust = 0.5),
                  plot.margin = ggplot2::unit(c(1,1,1,1),"cm"))
  
  ggsave(filename=paste0(workflow,"/traits/plots/",filename), dpi=150, width=50, height=20, units="cm", plot=g, device="png", bg="transparent")
}

upright_yield_traits = c("UBL","UBW","UBM","UTBM","UNS","UMFM","ULvW")
generateDensityPlots(cnj02.merged.mmeans.tb, upright_yield_traits, "phenotypes.upright_yield.density.cnj02.png")
generateDensityPlots(cnj04.merged.mmeans.tb, upright_yield_traits, "phenotypes.upright_yield.density.cnj04.png")

setwd(rRoot)
bbi_traits = c("BBITBM","BBITY","BBISFY","URB")
generateDensityPlots(cnj02.merged.mmeans.tb, bbi_traits, "phenotypes.bbi.density.cnj02.png")
generateDensityPlots(cnj04.merged.mmeans.tb, bbi_traits, "phenotypes.bbi.density.cnj04.png")

upright_yield2_traits = c("UL","USL","UDM","URB")
generateDensityPlots(cnj02.merged.mmeans.tb, upright_yield2_traits, "phenotypes.upright_yield2.density.cnj02.png")
generateDensityPlots(cnj04.merged.mmeans.tb, upright_yield2_traits, "phenotypes.upright_yield2.density.cnj04.png")

upright_ped_traits = c("UNP","UNB","UNAB","UN0","UNAF")
generateDensityPlots(cnj02.merged.mmeans.tb, upright_ped_traits, "phenotypes.upright_ped.density.cnj02.png")
generateDensityPlots(cnj04.merged.mmeans.tb, upright_ped_traits, "phenotypes.upright_ped.density.cnj04.png")

upright_other_traits = c("UCD","UCLP","UCLS","UBBL")
generateDensityPlots(cnj02.merged.mmeans.tb, upright_other_traits, "phenotypes.upright_other.density.cnj02.png")
generateDensityPlots(cnj04.merged.mmeans.tb, upright_other_traits, "phenotypes.upright_other.density.cnj04.png")

upright_chimera_shape_traits = c("UKLvW","UKEC","UKSO","UKTO", "UKUX", "UKUY")
generateDensityPlots(cnj02.merged.mmeans.tb, upright_chimera_shape_traits, "phenotypes.upright_shape.density.cnj02.png")
generateDensityPlots(cnj04.merged.mmeans.tb, upright_chimera_shape_traits, "phenotypes.upright_shape.density.cnj04.png")

plot_traits = c("TY","SFY","MFM","PFR","Tacy","Brix","TA","PAC")
generateDensityPlots(cnj02.merged.mmeans.tb, plot_traits, "phenotypes.plot_traits.density.cnj02.png")
generateDensityPlots(cnj04.merged.mmeans.tb, plot_traits, "phenotypes.plot_traits.density.cnj04.png")
```

### Define Functions to Generate Correlation Plots

```{r plotdata-corrs-function, include=TRUE, echo=TRUE}
dist2order = function(corr, method, ...) {
  d_corr = as.dist(1 - corr)
  if( method == "TSP" ) {
    s = seriate(d_corr, method = method, control=list(method="repetitive_nn", start=1, two_opt=TRUE, rep=50))
  } else {
    s = seriate(d_corr, method = method, ...)
  }
  i = get_order(s)
  return(i)
}

gencorrplot <- function(data.tb, data_is_cor=FALSE, filename=NULL, min_cor=0.0, width=1280, height=1024, seriate_method=NULL, method="square", type="lower", cl.pos='r', rect.spec=NULL, rect.labels=NULL, invert=FALSE, ...) {
    if( !is.null(filename) ) {
        png(filename=filename, bg="transparent", width=width, height=height, units='px')
    }
    col.gradient <- col1(100)
    if( data_is_cor ) {
        corr.tb <- data.tb$corr
        pvals <- data.tb$p.mat
    } else {
        corr.tb <- cor(data.tb, use="pairwise.complete.obs") 
        pvals <- tryCatch( {
            ggcorrplot::cor_pmat(data.tb)
        },
        error = function(e) NULL
        );
    }
    corr.tb.selected <- abs(corr.tb) > min_cor
    corr.tb <- matrix(corr.tb[corr.tb.selected], nrow=nrow(corr.tb.selected), ncol=ncol(corr.tb.selected),dimnames=dimnames(corr.tb.selected))
    if( !is.null(pvals) ) {
        pvals <- matrix(pvals[corr.tb.selected], nrow=nrow(corr.tb.selected), ncol=ncol(corr.tb.selected), dimnames=dimnames(corr.tb.selected))
    }
    if( !is.null(seriate_method) )
    {
        if( invert == TRUE ) {
            i = dist2order(-1.0 * corr.tb, seriate_method) #Flip the order -- put negative correlations closer to the diagonal
        } else {
            i = dist2order(corr.tb, seriate_method)
        }
        corr.tb = corr.tb[i,i]
        if( !is.null(pvals) ) {
            pvals = pvals[i,i]
        }
        p = corrplot(corr.tb, p.mat=pvals, order="original", insig="blank", tl.col="black", method=method, type=type, col=col.gradient, cl.pos=cl.pos, diag=FALSE, na.label=" ", ...)
    } 
    else if( data_is_cor ) {
        p = corrplot(corr.tb, p.mat=pvals, order="original", insig="blank", tl.col="black", method=method, type=type, col=col.gradient, cl.pos=cl.pos, diag=FALSE, na.label=" ", ...)
    }
    else 
    {
        tryCatch( {
            p = corrplot(corr.tb, p.mat=pvals, order="hclust", insig="blank", tl.col="black", method=method, type=type, col=col.gradient, cl.pos=cl.pos, diag=FALSE, na.label=" ", ...)
        },
        error = function(e) {
            p = corrplot(corr.tb, p.mat=pvals, order="original", insig="blank", tl.col="black", method=method, type=type, col=col.gradient, cl.pos=cl.pos, diag=FALSE, na.label=" ", ...)
        }
        )
        if(!exists("p")) { #For some reason errors aren't being caught and p is left undefined
            p = corrplot(corr.tb, p.mat=pvals, order="original", insig="blank", tl.col="black", method=method, type=type, col=col.gradient, cl.pos=cl.pos, diag=FALSE, na.label=" ", ...)
        }
    }
    if( !is.null(rect.spec) ) {
        p %>% corrRect(namesMat=rect.spec)
    }
    if( !is.null(rect.labels) ) {
        p %>% corrRect(name=rect.labels)
    }
    if( !is.null(filename) ) {
        dev.off()
    }
    p$rect.spec <- rect.spec
    p$rect.labels <- rect.labels
    p$p.mat <- pvals
    return(p)
}

gencorrplot.mixed <- function(data.tb, data_is_cor=FALSE, filename=NULL, min_cor=0.0, width=1280, height=1024, seriate_method=NULL, lower="square", upper="number", cl.pos='r', na.label = " ", invert=FALSE, rect.spec=NULL, rect.labels=NULL, ...) {
    if( !is.null(filename) ) {
        png(filename=filename, bg="transparent", width=width, height=height, units='px')
    }
    col.gradient <- col1(100)
    if( data_is_cor ) {
        corr.tb <- data.tb$corr
        pvals <- data.tb$p.mat
    } else {
        corr.tb <- cor(data.tb, use="pairwise.complete.obs") 
        pvals <- tryCatch( {
            ggcorrplot::cor_pmat(data.tb)
        },
        error = function(e) NULL
        );
    }
    corr.tb.selected <- abs(corr.tb) > min_cor
    corr.tb <- matrix(corr.tb[corr.tb.selected], nrow=nrow(corr.tb.selected), ncol=ncol(corr.tb.selected),dimnames=dimnames(corr.tb.selected))
    if( !is.null(pvals) ) {
        pvals <- matrix(pvals[corr.tb.selected], nrow=nrow(corr.tb.selected), ncol=ncol(corr.tb.selected), dimnames=dimnames(corr.tb.selected))
    }
    if( !is.null(seriate_method) )
    {
        if( invert == TRUE ) {
            i = dist2order(-1.0 * corr.tb, seriate_method)
        } else {
            i = dist2order(corr.tb, seriate_method)
        }
        corr.tb = corr.tb[i,i]
        if( !is.null(pvals) ) {
            pvals = pvals[i,i]
        }
        p = corrplot.mixed(corr.tb, p.mat=pvals, order="original", insig="blank", tl.col="black", lower=lower, upper=upper, lower.col=col.gradient, upper.col=col.gradient, na.label = " ", ...)
    } 
    else if( data_is_cor ) {
        p = corrplot.mixed(corr.tb, p.mat=pvals, order="original", insig="blank", tl.col="black", lower=lower, upper=upper, lower.col=col.gradient, upper.col=col.gradient, na.label = " ", ...)
    }
    else 
    {
        tryCatch( {
            p = corrplot.mixed(corr.tb, p.mat=pvals, order="hclust", insig="blank", tl.col="black", lower=lower, upper=upper, lower.col=col.gradient, upper.col=col.gradient, na.label = " ", ...)
        },
        error = function(e) {
            p = corrplot.mixed(corr.tb, p.mat=pvals, order="original", insig="blank", tl.col="black", lower=lower, upper=upper, lower.col=col.gradient, upper.col=col.gradient, na.label = " ", ...)
        }
        )
        if(!exists("p")) { #For some reason errors aren't being caught and p is left undefined
            p = corrplot(corr.tb, p.mat=pvals, order="original", insig="blank", tl.col="black", method=method, type=type, col=col.gradient, cl.pos=cl.pos, diag=FALSE, na.label=" ", ...)
        }
    }
    if( !is.null(rect.spec) ) {
        p %>% corrRect(namesMat=rect.spec)
    }
    if( !is.null(rect.labels) ) {
        p %>% corrRect(name=rect.labels)
    }
    if( !is.null(filename) ) {
        dev.off()
    }
    p$rect.spec <- rect.spec
    p$rect.labels <- rect.labels
    p$p.mat <- pvals
    return(p)
}
```

## Generate Plots of Correlation Matrices Across All Traits, Across Years

```{r plotdata-corrs, include=TRUE, echo=TRUE}
setwd(rRoot)

#Reload previously saved data
cnj02.merged.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ02_PlotData.csv"))
cnj02.merged.mmeans.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ02_PlotData.mmeans.csv"))
cnj02.merged.mmeans.std.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ02_PlotData.mmeans.std.csv"))
cnj04.merged.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ04_PlotData.csv"))
cnj04.merged.mmeans.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ04_PlotData.mmeans.csv"))
cnj02.merged.mmeans.std.tb <- read_csv(pheno_dpath2fpath("MergedData/CNJ02_PlotData.mmeans.std.csv"))

cnj02.alltraits.pw.tb <- cnj02.merged.mmeans.tb %>% 
                                  mutate(year = paste0("y",year)) %>%
                                  pivot_longer(cols=BBITBM:PAC, names_to='trait', values_to='value') %>% 
                                  pivot_wider(names_from=year, values_from=value)
gencorrplot(cnj02.alltraits.pw.tb %>% select(!c(accession_name, accession, row, column, trait)), filename=paste0(workflow,"/traits/plots/corrplot.cnj02.alltraits.png"), method="number", cl.pos='n')

cnj04.alltraits.pw.tb <- cnj04.merged.mmeans.tb %>% 
                                  filter(year != '13') %>% #Filter out 2013, as data does not overlap with other datasets
                                  mutate(year = paste0("y",year)) %>%
                                  pivot_longer(cols=BBITBM:PAC, names_to='trait', values_to='value') %>% 
                                  pivot_wider(names_from=year, values_from=value)
gencorrplot(cnj04.alltraits.pw.tb %>% select(!c(accession_name, accession, row, column, trait)), filename=paste0(workflow,"/traits/plots/corrplot.cnj04.alltraits.png"), method="number", cl.pos='n')
```

### Generate Correlation Matrices Across Months and Years

```{r include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
cnj02.merged.wider.tb <- pivot_wider(cnj02.merged.tb, names_from=c(year), values_from=UNP:PACOct, names_sep="")
gencorrplot(cnj02.merged.wider.tb %>% select(!c(accession_name, accession, row, column)), filename=paste0(workflow,"/traits/plots/corrplot.cnj02.ym.png"), width=2560, height=2048, tl.srt=45, tl.cex=2, cl.cex=2)

cnj04.merged.wider.tb <- pivot_wider(cnj04.merged.tb %>% filter(year != 13), names_from=c(year), values_from=UNP:PACOct, names_sep="") #Filter out 2013 b/c it is only represented for parents of plot dataset -- no equivalent in other data
setwd(rRoot)
gencorrplot(cnj04.merged.wider.tb %>% select(!c(accession_name, accession, row, column)), filename=paste0(workflow,"/traits/plots/corrplot.cnj04.ym.png"), width=2560, height=2048, tl.srt=45, tl.cex=2, cl.cex=2)
```

### Generate Correlation Matrices Across Years

```{r include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
cnj02.merged.mmeans.wider.tb <- pivot_wider(cnj02.merged.mmeans.tb, names_from=c(year), values_from=BBITBM:PAC, names_sep="")
gencorrplot(cnj02.merged.mmeans.wider.tb %>% select(!c(accession_name, accession, row, column)), filename=paste0(workflow,"/traits/plots/corrplot.cnj02.y.png"), width=2048, height=2200, tl.srt=45, tl.cex=1.8, cl.cex=1.8)

cnj04.merged.mmeans.wider.tb <- cnj04.merged.mmeans.tb %>% 
                                filter(year != '13') %>%
                                pivot_wider(names_from=c(year), values_from=BBITBM:PAC, names_sep="")
gencorrplot(cnj04.merged.mmeans.wider.tb %>% select(!c(accession_name, accession, row, column)), filename=paste0(workflow,"/traits/plots/corrplot.cnj04.y.png"), width=2048, height=2200, tl.srt=45, tl.cex=1.8, cl.cex=1.8)

```

### Generate Correlation Matrices With Traits Averaged Across Months and Years

```{r include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)

cnj02.merged.means.tb <- cnj02.merged.mmeans.tb %>%
                          group_by(accession_name, row, column) %>%
                          summarise(across(.cols=BBITBM:PAC, mean, na.rm=TRUE)) %>%
                          ungroup()
cnj02.merged.means.cor <- cor(cnj02.merged.means.tb %>% select(!c(accession_name, row, column)), use="pairwise.complete.obs")
write.csv(cnj02.merged.means.cor, file=paste0(workflow,"/traits/plots/corrplot.cnj02.csv"))
gencorrplot.mixed(cnj02.merged.means.tb %>% select(!c(accession_name, row, column)), filename=paste0(workflow,"/traits/plots/corrplot.cnj02.png"), width=2048, height=2048, tl.cex=1, cl.cex=1, number.cex=1.5)

cnj04.merged.means.tb <- cnj04.merged.mmeans.tb %>%
                          group_by(accession_name, row, column) %>%
                          summarise(across(.cols=BBITBM:PAC, mean, na.rm=TRUE)) %>%
                          ungroup()
gencorrplot.mixed(cnj04.merged.means.tb %>% select(!c(accession_name, row, column)), filename=paste0(workflow,"/traits/plots/corrplot.cnj04.png"), width=2048, height=2048, tl.cex=1, cl.cex=1, number.cex=1.5)
cnj04.merged.means.cor <- cor(cnj04.merged.means.tb %>% select(!c(accession_name, row, column)), use="pairwise.complete.obs")
write.csv(cnj04.merged.means.cor, file=paste0(workflow,"/traits/plots/corrplot.cnj04.csv"))
```

------------------------------------------------------------------------

## A different approach, but see if seriation of data based on raw trait values offers any insights into trait/genotype structure.

Run the following repeatedly until you like how the graph looks. This is because th results are not determinisitic.

```{r seriation-cnj02-pre, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj02 = gencorrplot.mixed(cnj02.merged.means.tb %>% select(!c(accession_name, row, column)), width=2048, height=2048, tl.cex=1.0, cl.cex=1.0, number.cex=1.5,seriate_method="TSP")
saveRDS(p.cnj02, file=paste0(workflow,"/traits/plots/corrplot.cnj02.rds"))
```

```{r seriation-cnj02-flat, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
top_rank = 15 #Number of top and bottom correlations to show
p.cnj02 = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj02.rds"))
pf.cnj02 = flattenCorrMatrix(p.cnj02$corr, p.cnj02$p.mat) %>%
                filter(p < 0.05) %>%
                arrange(desc(cor))
pf.cnj02.inv <-  pf.cnj02  %>% 
                     arrange(cor)
write_csv(pf.cnj02, file=paste0(workflow,"/traits/plots/corrplot.cnj02.flattened.csv"))
write_csv(pf.cnj02.inv, file=paste0(workflow,"/traits/plots/corrplot.cnj02.flattened.inv.csv"))
pf.cnj02.extremes <- rbind(pf.cnj02 %>% head(top_rank), pf.cnj02 %>% tail(top_rank)) %>%
                        mutate(row_column=paste0(row," × ",column)) %>%
                        mutate(row_column=factor(row_column, levels=row_column, ordered=TRUE))
png(filename=paste0(workflow,"/traits/plots/corrplot.cnj02.flat.png"), bg="white", width=840, height=2048, units='px')
p <- ggplot(pf.cnj02.extremes, aes(x=row_column,y=cor)) + 
        geom_bar(aes(fill=cor), stat="identity", alpha=0.75, show.legend=FALSE) + 
		scale_fill_distiller(
				type="div",
				palette="RdBu",
				direction=-1) +
        geom_text(aes(label=sprintf("%0.2f", round(cor, digits = 2)),fontface="bold"),size=7,nudge_y=ifelse(pf.cnj02.extremes$cor < 0, -0.10, 0.10)) +
        ylim(-1.2,1.2) +
        theme_minimal() +
        theme(plot.margin = margin(l=50,unit='pt'),
              axis.title = element_text(face="bold",size=14),
              axis.text.x  = element_text(face="bold",size=18,angle=30,vjust=0.2),
              axis.text.y  = element_text(face="bold",size=18,angle=30)) +
        ylab("") + 
        xlab("") +
        coord_flip()
p
dev.off()
```

```{r seriation-cnj02-inv-pre, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj02.inv = gencorrplot.mixed(cnj02.merged.means.tb %>% select(!c(accession_name, row, column)), width=2048, height=2048, tl.cex=1.0, cl.cex=1.0, number.cex=1.5,seriate_method="TSP", invert=TRUE)
saveRDS(p.cnj02.inv, file=paste0(workflow,"/traits/plots/corrplot.cnj02.inv.rds"))
```

```{r seriation-cnj04-pre, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj04 = gencorrplot.mixed(cnj04.merged.means.tb %>% select(!c(accession_name, row, column)), width=2048, height=2048, tl.cex=1.0, cl.cex=1.0, number.cex=1.5, seriate_method="TSP")
saveRDS(p.cnj04, file=paste0(workflow,"/traits/plots/corrplot.cnj04.rds"))
```

```{r seriation-cnj04-flat, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
top_rank=15
p.cnj04 = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj04.rds"))
pf.cnj04 = flattenCorrMatrix(p.cnj04$corr, p.cnj04$p.mat) %>%
                filter(p < 0.05) %>%
                arrange(desc(cor))
pf.cnj04.inv <-  pf.cnj04  %>% 
                     arrange(cor)
write_csv(pf.cnj04, file=paste0(workflow,"/traits/plots/corrplot.cnj04.flattened.csv"))
write_csv(pf.cnj04.inv, file=paste0(workflow,"/traits/plots/corrplot.cnj04.flattened.inv.csv"))
pf.cnj04.extremes <- rbind(pf.cnj04 %>% head(top_rank), pf.cnj04 %>% tail(top_rank)) %>%
                        mutate(row_column=paste0(row," × ",column)) %>%
                        mutate(row_column=factor(row_column, levels=row_column, ordered=TRUE))
png(filename=paste0(workflow,"/traits/plots/corrplot.cnj04.flat.png"), bg="white", width=840, height=2048, units='px')
p <- ggplot(pf.cnj04.extremes, aes(x=row_column,y=cor)) + 
        geom_bar(aes(fill=cor), stat="identity", alpha=0.75, show.legend=FALSE) + 
		scale_fill_distiller(
				type="div",
				palette="RdBu",
				direction=-1) +
        geom_text(aes(label=sprintf("%0.2f", round(cor, digits = 2)),fontface="bold"),size=7,nudge_y=ifelse(pf.cnj04.extremes$cor < 0, -0.1, 0.1)) +
        ylim(-1.2,1.2) +
        theme_minimal() +
        theme(plot.margin = margin(l=30,unit='pt'),
              axis.title = element_text(face="bold",size=14),
              axis.text.x  = element_text(face="bold",size=18,angle=30,vjust=0.2),
              axis.text.y  = element_text(face="bold",size=18,angle=30)) +
        ylab("") + 
        xlab("") +
        coord_flip()
p
dev.off()

```

```{r seriation-cnj04-inv-pre, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj04.inv = gencorrplot.mixed(cnj04.merged.means.tb %>% select(!c(accession_name, row, column)), width=2048, height=2048, tl.cex=1.0, cl.cex=1.0, number.cex=1.5, seriate_method="TSP",invert=TRUE)
saveRDS(p.cnj04.inv, file=paste0(workflow,"/traits/plots/corrplot.cnj04.inv.rds"))
```

```{r seriation, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj02 = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj02.rds"))
gencorrplot.mixed(p.cnj02, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj02.ts.png"), width=2048, height=2048, tl.cex=1, cl.cex=1, number.cex=1.5, rect.spec=rbind(c("UKUX","UKUX","UBL","UBL"),c("UBL","UBL","UTBM","UTBM"),c("UTBM","UTBM","UNB","UNB"),c("UBL","TA","UNP","UNS"),c("TA","UBL","UNS","UNP")))
p.cnj02.inv = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj02.inv.rds"))
setwd(rRoot)
gencorrplot.mixed(p.cnj02.inv, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj02.ts.inv.png"), width=2048, height=2048, tl.cex=1, cl.cex=1, number.cex=1.5, rect.spec=rbind(c("PAC","PAC","TY","TY"),c("UCLP","UCLP","UCLS","UCLS"),c("ULvW","ULvW","UKTO","UKTO"),c("Brix","Brix","MFM","MFM"),c("Brix","Brix","Brix","UMFM"),c("Brix","UMFM","UMFM","UMFM"),c("SFY","SFY","PAC","SFY"),c("PAC","SFY","PAC","PAC")))
p.cnj04 = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj04.rds"))
gencorrplot.mixed(p.cnj04, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj04.ts.png"), width=2048, height=2048, tl.cex=1, cl.cex=1, number.cex=1.5, rect.spec=rbind(c("UTBM","UTBM","UBL","UBL"),c("UBL","UBL","UKUX","UKUX")))
p.cnj04.inv = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj04.inv.rds"))
gencorrplot.mixed(p.cnj04.inv, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj04.ts.inv.png"), width=2048, height=2048, tl.cex=1, cl.cex=1, number.cex=1.5, rect.spec=rbind(c("UBL","UBL","UBM","UBM"),c("PAC","PAC","TY","TY"),c("UCLP","UCLP","UCLS","UCLS"),c("UNB","UNB","PFR","PFR"),c("URB","URB","UNS","UNS"),c("MFM","MFM","UBW","UBW"),c("UNP","UNP","TA","TA")))
```

```{r seriation-cnj02-pre-refined, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj02.refined = gencorrplot.mixed(cnj02.merged.means.tb %>% select(!c(accession_name, row, column)) %>% select(c(UKUX,UKLvW,UKEC,ULvW,UBL,MFM,UMFM,UBM,UBW,UTBM,UNB,UNP,TA,TY,SFY,UNAB,UNS)), width=2048, height=2048, tl.cex=0.75, cl.cex=0.75, number.cex=0.75,seriate_method="TSP")
saveRDS(p.cnj02.refined, file=paste0(workflow,"/traits/plots/corrplot.cnj02.refined.rds"))
```

```{r seriation-cnj02-inv-pre-refined, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj02.inv.refined = gencorrplot.mixed(cnj02.merged.means.tb %>% select(!c(accession_name, row, column)) %>% select(c(PAC,TY,SFY,UCLP,UCLS,ULvW,UKTO,Brix,MFM,UMFM)), width=2048, height=2048, tl.cex=0.75, cl.cex=0.75, number.cex=0.75,seriate_method="TSP", invert=TRUE)
saveRDS(p.cnj02.inv.refined, file=paste0(workflow,"/traits/plots/corrplot.cnj02.inv.refined.rds"))
```

```{r seriation-cnj04-pre-refined, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj04.refined = gencorrplot.mixed(cnj04.merged.means.tb %>% select(!c(accession_name, row, column)) %>% select(c(UTBM,UBW,MFM,UMFM,UBM,UBL,ULvW,UKEC,UKLvW,UKUX)), width=2048, height=2048, tl.cex=0.75, cl.cex=0.75, number.cex=0.75,seriate_method="TSP")
saveRDS(p.cnj04.refined, file=paste0(workflow,"/traits/plots/corrplot.cnj04.refined.rds"))
```

```{r seriation-cnj04-inv-pre-refined, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj04.inv.refined = gencorrplot.mixed(cnj04.merged.means.tb %>% select(!c(accession_name, row, column)) %>% select(c(URB,USL,UNS,MFM,BBITBM,UBW,UCLP,UCLS,UNB,PFR,PAC,TY,UBL,Brix,UBM,UNP,TA)), width=2048, height=2048, tl.cex=0.75, cl.cex=0.75, number.cex=0.75,seriate_method="TSP", invert=TRUE)
saveRDS(p.cnj04.inv.refined, file=paste0(workflow,"/traits/plots/corrplot.cnj04.inv.refined.rds"))
```

```{r seriation-refined, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj02.refined = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj02.refined.rds"))
gencorrplot.mixed(p.cnj02.refined, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj02.refined.png"), width=2048, height=2048, tl.cex=2, cl.cex=2, number.cex=2.5)
p.cnj02.inv.refined = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj02.inv.refined.rds"))
gencorrplot.mixed(p.cnj02.inv.refined, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj02.inv.refined.png"), width=2048, height=2048, tl.cex=2, cl.cex=2, number.cex=2.5, invert=TRUE)
p.cnj04.refined = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj04.refined.rds"))
gencorrplot.mixed(p.cnj04.refined, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj04.refined.png"), width=2048, height=2048, tl.cex=2, cl.cex=2, number.cex=2.5)
p.cnj04.inv.refined = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj04.inv.refined.rds"))
gencorrplot.mixed(p.cnj04.inv.refined, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj04.inv.refined.png"), width=2048, height=2048, tl.cex=2, cl.cex=2, number.cex=2.5, invert=TRUE)
```

##Generate correlation plots using hclust and only rendering non-singletons in clustering cut

```{r hclust-nonsingletons-cnj02-pre-refined, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
data <- cnj02.merged.means.tb %>% select(!c(accession_name, row, column))
corr.tb <- cor(data, use="pairwise.complete.obs") 
pvals <- tryCatch( {
    ggcorrplot::cor_pmat(data)
},
error = function(e) NULL
);
hclusts <- hclust(as.dist(1-abs(corr.tb)), method="complete")
#clusts <- sort(cutree(hclusts, h = .60 ))
clusts <- cutree(hclusts, h = .60)[hclusts$order]
clusts.d <- duplicated(clusts)
clusts.d.lshift <- c(clusts.d[2:length(clusts.d)],FALSE)
clusts.nsingleton <- clusts[clusts.d | clusts.d.lshift]
nns <- names(clusts.nsingleton)
rl <- rle(clusts.nsingleton)$lengths
corr.tb <- corr.tb[nns,nns] #Prune out singletons
rect.labels <- nns[c(cumsum(c(1,rl[1:length(rl)-1])),length(nns))]
if( !is.null(pvals) ) {
    pvals <- pvals[nns,nns]
}
data.tb <- list(corr=corr.tb, p.mat=pvals)
p.cnj02.nonsingletons = gencorrplot(data.tb, data_is_cor = TRUE, width=2048, height=2048, tl.cex=0.4, cl.cex=0.75, number.cex=0.40, type="full", rect.labels=rect.labels,page=FALSE)
saveRDS(p.cnj02.nonsingletons, file=paste0(workflow,"/traits/plots/corrplot.cnj02.nonsingletons.squares.rds"))
p.cnj02.nonsingletons = gencorrplot(data.tb, data_is_cor = TRUE, width=2048, height=2048, tl.cex=0.4, cl.cex=0.75, number.cex=0.40, method="number", type="full", rect.labels=rect.labels)
saveRDS(p.cnj02.nonsingletons, file=paste0(workflow,"/traits/plots/corrplot.cnj02.nonsingletons.numbers.rds"))
```

```{r hclust-nonsingletons-cnj04-pre-refined, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
data <- cnj04.merged.means.tb %>% select(!c(accession_name, row, column))
corr.tb <- cor(data, use="pairwise.complete.obs") 
pvals <- tryCatch( {
    ggcorrplot::cor_pmat(data)
},
error = function(e) NULL
);
hclusts <- hclust(as.dist(1-abs(corr.tb)), method="complete")
#clusts <- sort(cutree(hclusts, h = .60 ))
clusts <- cutree(hclusts, h = .60)[hclusts$order]
clusts.d <- duplicated(clusts)
clusts.d.lshift <- c(clusts.d[2:length(clusts.d)],FALSE)
clusts.nsingleton <- clusts[clusts.d | clusts.d.lshift]
nns <- names(clusts.nsingleton)
rl <- rle(clusts.nsingleton)$lengths
corr.tb <- corr.tb[nns,nns] #Prune out singletons
rect.labels <- nns[c(cumsum(c(1,rl[1:length(rl)-1])),length(nns))]
if( !is.null(pvals) ) {
    pvals <- pvals[nns,nns]
}
data.tb <- list(corr=corr.tb, p.mat=pvals)
p.cnj04.nonsingletons = gencorrplot(data.tb, data_is_cor = TRUE, width=2048, height=2048, tl.cex=0.4, cl.cex=0.75, number.cex=0.40, type="full", rect.labels=rect.labels)
saveRDS(p.cnj04.nonsingletons, file=paste0(workflow,"/traits/plots/corrplot.cnj04.nonsingletons.squares.rds"))
p.cnj04.nonsingletons = gencorrplot(data.tb, data_is_cor = TRUE, width=2048, height=2048, tl.cex=0.4, cl.cex=0.75, number.cex=0.40, method="number", type="full", rect.labels=rect.labels)
saveRDS(p.cnj04.nonsingletons, file=paste0(workflow,"/traits/plots/corrplot.cnj04.nonsingletons.numbers.rds"))
```

```{r nonsingletons-refined, include=TRUE, warning=FALSE, echo=FALSE}
setwd(rRoot)
p.cnj02.nonsingletons.squares = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj02.nonsingletons.squares.rds"))
gencorrplot(p.cnj02.nonsingletons.squares, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj02.nonsingletons.squares.png"), width=2048, height=2048, tl.cex=2, cl.cex=2, number.cex=2.5, type='full', rect.labels=p.cnj02.nonsingletons.squares$rect.labels)
p.cnj02.nonsingletons.numbers = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj02.nonsingletons.numbers.rds"))
gencorrplot(p.cnj02.nonsingletons.numbers, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj02.nonsingletons.numbers.png"), width=2048, height=2048, tl.cex=2, cl.cex=2, number.cex=2.5, method="number", type='full', rect.labels=p.cnj02.nonsingletons.numbers$rect.labels)
p.cnj04.nonsingletons.squares = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj04.nonsingletons.squares.rds"))
gencorrplot(p.cnj04.nonsingletons.squares, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj04.nonsingletons.squares.png"), width=2048, height=2048, tl.cex=2, cl.cex=2, number.cex=2.5, type='full', rect.labels=p.cnj04.nonsingletons.squares$rect.labels)
p.cnj04.nonsingletons.numbers = readRDS(paste0(workflow,"/traits/plots/corrplot.cnj04.nonsingletons.numbers.rds"))
gencorrplot(p.cnj04.nonsingletons.numbers, data_is_cor=TRUE, filename=paste0(workflow,"/traits/plots/corrplot.cnj04.nonsingletons.numbers.png"), width=2048, height=2048, tl.cex=2, cl.cex=2, number.cex=2.5, method="number", type='full', rect.labels=p.cnj04.nonsingletons.numbers$rect.labels)
```

## Fit and Analyze Models

The following code fits models according to the specification in the folder Workflows/`r params$workflow`/, and then executes an drop-one ANOVA analysis to look for significance in effects.

```{r model-fit}
setwd(rRoot);
source('qtl_pipeline_01_genmodels.R', echo=FALSE);
```

```{r model-analyze}
setwd(rRoot);
source('qtl_pipeline_01_analyzemodels.R', echo=FALSE);
```

------------------------------------------------------------------------

## Generate Plots Based on Models

```{r model-plots}
setwd(rRoot);
#source('qtl_pipeline_01_02_genh2plots.R', echo=FALSE); 
source('qtl_pipeline_01_03_genBLUPplots.R', echo=FALSE); 
```

------------------------------------------------------------------------

## Run Perms on HTCondor System

In order to calculate QTL LOD-score significance, permutations of the functions that execute QTL Mapping in the `r/QTL` package, `scanone()` and `scantwo()`, will be run on the UW Madison HTCondor System.

The steps needed to run these these permutations and pull that information off the HTCondor server are best executed by the `Makefile` defined in `Scripts/R/` folder.

### Build R Package Dependencies and Bundle in Tarball Archive

This is necessary to run the needed functionality on the HTCondor compute nodes. These dependencies are defined in the `HTCondorFiles/packagedeps.chtc.R` file. Variables such as `R_VERSION`, `USERNAME`, and `SUBMIT_SERVER` are configurable. The former is defined based the available R versions supported by the UW Madison HTCondor system (see online documentation), and the latter two must be specified based on the account username and submit server URL you are given when you register with UW Madison CHTC to use their high throughput compute system. `R_VERSION` is currently defined in ``` r workflow``/config/perms.mk ```.

    make Rbuild

After the dependent packages been generated by an HTCondor node and placed in an archive, you can download the package dependency tarball by typing the following:

    make RDownload

*NOTE:* Use the `condor_q` script on the sumbit server, through an ssh terminal prompt, to query and see when the node is finished (and whether it finished successfully).

### Automatically Construct a Set of HTCondor Submit Scripts for 1D QTL Map Permutations

A python script is supplied in HTCondors/ file to construct the necessary contingent of HTCondor scripts needed to parcel out the permutations onto separate compute nodes of the HTCondor system. This is due to the fact that HTCondor requires explicitly definining the number of needed nodes.

Parameters that define the total number of permutations to run per model (`TOTAL_PERMS_PER_TRAIT`), and the number of compute nodes to distribute permutation computations across (`NUM_CLUSTERS_PER_TRAIT`), are defined in ``` r workflow``/config/perms.mk ```. Together, these `TOTAL_PERMS_PER_TRAIT/NUM_CLUSTERS_PER_TRAIT` define the number of permutations run on each independent compute node. `START_SEED` doesn't need to be changed, but helps generate some randomness to the permutation process. The seed used is saved in a file so that the results can be recapitulated.

    WORKFLOW=<WORKFLOW_FOLDER_HERE> make PermBuild

You could be prompted for your account password, and this will also copy the packaged HTCondor scripts, their parameters, and their necessary dependencies to teh submit node.

### Run the 1D QTL Map Permutations

    WORKFLOW=<WORKFLOW_FOLDER_HERE> make RunPerms

This could take some time to execute, depending on the available compute node resources. You can query the status of your submission through `condor_q` executable.

### Download 1D QTL Map Permutation Results and Merge into One Dataset

    WORKFLOW=<WORKFLOW_FOLDER_HERE> make PullPerms
    WORKFLOW=<WORKFLOW_FOLDER_HERE> make PermMerge

### Automatically Construct a Set of HTCondor Submit Scripts for 2D QTL Map Permutations

Just as in the 1D case, you will need to generate a list of HTCondor scripts to parcel out the 2D QTL mapping permutations on the compute nodes.

    WORKFLOW=<WORKFLOW_FOLDER_HERE> make Perm2DBuild

### Run the 2D QTL Map Permutations

    WORKFLOW=<WORKFLOW_FOLDER_HERE> make RunPerms2D

### Download 2D QTL Map Permutation Results and Merge into One Dataset

    WORKFLOW=<WORKFLOW_FOLDER_HERE> make PullPerms2D
    WORKFLOW=<WORKFLOW_FOLDER_HERE> make Perm2DMerge

After running the set of permutations and downloading/merging these, you shouldn't need to rerun these steps as long as you don't change the fitted model params for your traits. The merged permutation calculations will be available in an R binary data file format (rds extension), under the subfolder relevant to each trait in your workflow. The 1D permutations will be saved as an `operm.rds` file, and the 2D permutations will be saved as an `operm.2D.rds` files. These files will loaded by subsequent scripts to determine QTL significance.

------------------------------------------------------------------------

## Run the 1D QTL Scan

This code will call the `R/qtl:scanone()` function to execute a single-QTL scan through the genome. Parameters defining the regression method (i.e. Halley-Knot) and the significance levels are currently defined in your workflow folder under ``` r workflow``/config/model.cfg ```.

```{r qtl-1D}
setwd(rRoot);
source('qtl_pipeline_04_scanone.R', echo=FALSE); 
```

------------------------------------------------------------------------

## Run the Model Selection QTL Scan and Fit QTL

This code will call the `R/qtl:stepwiseqtl()` function to execute a single-QTL scan through the genome, and also call `R/qtl:fitqtl()` to fit found QTL.

```{r qtl-MQTL}
setwd(rRoot);
source('qtl_pipeline_07_stepwiseqtl.local.R', echo=FALSE); 
source('qtl_pipeline_08_makefitqtls.R', echo=FALSE); 
```

------------------------------------------------------------------------

## Collate QTL Results into One Table

All significant results will be collated into a single table and stored in a csv file in your selected workflow folder.

```{r qtl-collate}
setwd(rRoot);
source('qtl_pipeline_09_collate.R', echo=FALSE); 
```

------------------------------------------------------------------------

## Display QTL Table Results - ScanOne

```{r qtl-table}
setwd(rRoot);
num_top_qtl = 2; #Specifies the number of top QTL to return per trait
qtl_method = "scanone" #First display 'scanone' results
source('qtl_pipeline_10_01_genQTLtables.R', echo=FALSE); 
```

## Display QTL Table Results - StepwiseQTL

```{r qtl-table-sw}
setwd(rRoot);
num_top_qtl = 2; #Specifies the number of top QTL to return per trait
qtl_method = "stepwiseqtl" #Display 'stepwiseqtl' results
source('qtl_pipeline_10_01_genQTLtables.R', echo=FALSE); 
```

------------------------------------------------------------------------

## Generate Consensus QTL

This was something that Luis did, but essentially trait QTL within 5 cM of each other across model years are treated as equivalent.

```{r qtl-consensus}
setwd(rRoot);
source('qtl_pipeline_10_genconsensus.R', echo=FALSE);
```

------------------------------------------------------------------------

## Generate QTL Effect Plots/Tables

Calculate QTL effect sizes and generate effect plots/tables.

```{r qtl-circos}
```

```{r qtl-circos}
setwd(rRoot);
source('qtl_pipeline_11_gencircos.R', echo=FALSE);
```

```{r qtl-effects}
setwd(rRoot);
source('qtl_pipeline_12_geneffects.R', echo=FALSE);
```

------------------------------------------------------------------------

## Generate Circos Plots of Significant QTL

Generate the necessary files to display significant QTL found in circos plot format. Uses [Circos.js](https://github.com/nicgirault/circosJS) library as framework to generate interactive circos plots in javascript.

------------------------------------------------------------------------

## Launch Local HTTP Server to Render QTL Circos Plots

Copy the files needed to render the circos plots to a sandbox folder, defined in RMarkdown params as `r sandbox`. Launch a local http server to render/view the circos plots and interact with them.

*NOTE*: You will need to install the node package manager command-line utility, [npm](https://www.npmjs.com/), on your system before running this.

```{bash qtl-circos-render}
cd R/
make GenCircosSandbox
make LaunchCircosSandbox
```
